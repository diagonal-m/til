

# 論理設計と正規化〜なぜテーブルは分割する必要があるのか〜

> ・リレーショナルデータベースにおけるテーブルとは、「同じ種類の物の集合」のこと
>
> ・「キー」とは、ある情報を引き出すための鍵です。特に、テーブルで最も重要なのが「主キー」です
>
> ・「正規化」は、データの冗長性をなくしていく作業です。その目的は更新時のデータ不整合を防止する
> 　   ことにあります
>
> ・正規化を理解するためには、関数従属の概念を理解する必要がありますが、これの基礎になっているの
> 　が「キー」の概念
>
> ・正規化を進めていくほどデータ整合性は高まりますが、検索性能が劣化します。通常は第3正規形までを
> 　考えれば十分



## テーブルとは何か

- テーブルと表の違い
- テーブルとは何か



### 二次元表≠テーブル

- 「社員」テーブル

| 社員ID | 社員名 | 年齢 | 部署 |
| ------ | ------ | ---- | ---- |
| 000A   | 加藤   | 40   | 開発 |
| 000B   | 藤本   | 32   | 人事 |
| 001F   | 三島   | 50   | 営業 |
| 001D   | 斉藤   | 47   | 営業 |

- ↑ テーブルは「社員」という共通点を持ったレコードの集合になっている
- テーブルとは
  - 形だけ二次元表であるだけはダメ
  - 「**ある共通点を持ったレコードを集めたもの**」である必要がある
  - 「テーブルとは同じ種類の物の集合である」とも言える
  - 「テーブル名はすべて複数形または複数名詞で書ける」と表現できる

> テーブル名は英語ならば複数形/複数名詞で書ける。そうでなければそのテーブルにはどこか間違いがある



## テーブルの構成要素

### 行と列

- テーブルにおいても横と縦のデータの組みを「行」と「列」と呼ぶ
  - 「レコード」と「カラム」という呼び方もする

### キー

- テーブルに必須の「**キー**(key)」
  - 何の「鍵」
    - ある特定のデータを引き出すための鍵
    - RDBでは「あるレコード(1行とは限らない)を特定するための列の組み合わせ」という意味で使う

#### 主キー

- 「**主キー**」、または「**プライマリーキー(primary key)**」と呼ぶ
  - 主キーは、テーブルにおいて必ず1つ存在しなければならず、かつ１つしか存在しない
  - 主キーとは、その値を指定すれば、必ず1行のレコードを特定できるような列の組み合わせのこと
    - 「一意に識別する」

> テーブルには重複行は存在できない



#### 外部キー

- 「**外部キー(foreign key)**」
  - 2つのテーブル間の列同士で設定するもの

社員

| 社員ID | 社員名 | 年齢 | 部署 |
| ------ | ------ | ---- | ---- |
| 000A   | 加藤   | 40   | 開発 |
| 000B   | 藤本   | 32   | 人事 |
| 001F   | 三島   | 50   | 営業 |
| 001D   | 斉藤   | 47   | 営業 |

部署

| 部署 |
| ---- |
| 開発 |
| 人事 |
| 営業 |
| 総務 |

- ↑では「社員」テーブルの「部署」列が「外部キー」
- この列は、部署の一覧を保持する「部署」テーブルの「部署」列を参照している
- この外部キーの役割は、「部署」テーブルに存在しないような部署のデータが、間違って「社員」テーブルに登録されないように防止すること
- いわば外部キーの役割は「社員」テーブルに対して一種の「制約(constraint)」を課すことである
  - この制約を「**参照整合性制約**」と呼ぶ

> 外部キーは人間の親子関係と同じ、子は親が存在しないと存在できないが、子のいない親は存在しうる

　

> 外部キーが設定されている場合、データの削除は子から順番に操作するのが吉



### 制約

- テーブルには、いくつかの制約をつけることができる
  1. NOT NULL制約
  2. 一意制約
  3. CHECK制約

#### ①NOT NULL制約

- 可能な限りデータはNULLにしない、というのがデータベース設計における大方針
- 「この列は絶対にNULLにはならない」ということがわかっている列については、NULLを禁止することができる
- この制約は、列単位で設定することができる。
- NOT NULL制約が設定された列にNULLのデータを登録しようとしたり、NULLに更新しようとしたりした場合、そのSQL文はエラーになる

> テーブル設計において、列には可能な限りNOT NULL制約を付加する



#### ②一意制約

- ある列の組について一意性を求める制約
- その点で、主キーと似ているが、主キーがテーブルにつき一つしか設定できないのに対し、一意制約は何個も設定できる



#### ③CHECK制約

- ある列の取りうる値の範囲を制限するための制約



### テーブルと列の名前

#### ルール１名前に使える文字集合

1. 半角のアルファベット
2. 半角の数字
3. アンダーバー( _ )



## 正規化とは何か？

- 論理設計において、特に理解を深めておくべき概念
  - 「**正規化**」およびそれによって作られる「**正規形**」



### 正規形の定義

- データベースで保持するデータの冗長性を排除し、一貫性と効率性を保持するためのデータ形式
- 一つの情報が複数のテーブルに存在して無駄なデータ領域と面倒な更新処理を発生させてしまう(冗長性)
- こうした冗長なデータを保持していると、更新処理のタイムラグによってデータの不整合が発生したり、そもそもデータを登録することができないようなテーブルを作ってしまうことがある(**非一貫性**)
- こうした冗長性や非一貫性の問題を解決するために考案された方法論が正規化

> 正規形のレベルは第５まであるが、普通は第3正規形まで理解すれば十分。



## 第1正規形

### 第1正規形の定義〜スカラ値の原則

- 便宜的にテーブルの行と列が交差する特定の一マスのことを「セル」と呼ぶ
- 第１正規形の定義とは「**一つのセルの中には一つの値しか含まない**」

- 一つのセルに一つだけの値が含まれているとき、この値のことを「**スカラ値**」と呼ぶ



## 第2正規形〜部分関数従属

- 第１正規形(第２正規形)ではないテーブル

| 会社コード(主キー) | 会社名 | 社員ID(主キー) | 社員名 | 年齢 | 部署コード | 部署名 |
| ------------------ | ------ | -------------- | ------ | ---- | ---------- | ------ |
| C0001              | A商事  | 000A           | 加藤   | 40   | D01        | 開発   |
| C0001              | A商事  | 000B           | 藤本   | 32   | D02        | 人事   |
| C0001              | A商事  | 001F           | 三島   | 50   | D03        | 営業   |
| C0002              | B化学  | 000A           | 斉藤   | 47   | D03        | 営業   |
| C0002              | B化学  | 009F           | 田島   | 25   | D01        | 開発   |
| C0002              | B化学  | 010A           | 渋谷   | 33   | D04        | 総務   |

- 上記テーブルはいずれのセルもスカラ値から構成されているため、第１正規形であると言える

- しかし、このテーブルはまだ第２正規形ではない

  - このテーブルにおける関数従属が「完全」ではない

  - このテーブルに主キーは{会社コード、社員ID}

    → 他の全ての列はこのキーに従属するはず

    → 会社名列だけ、主キーの一部である「会社コード」に従属している

    → 以下のような関数従属性がある

    \|会社コード| → |会社名|

- 主キーの一部の列に対して従属する列がある場合、この関係を**部分関数従属**と呼ぶ
- 主キーを構成するすべての列に従属性がある場合を、**完全関数従属性**と呼ぶ
- 第２正規形
  - テーブル内で部分関数従属を解消し、完全関数従属のみのテーブルを作ること

> 第２正規形は、部分関数従属を解消することで得られる



### 第２正規化を行う

- 部分関数従属を解消する手段
  - テーブルの分割
- 第２正規形にするには↓のように部分関数従属の関係にあるキー列と従属列だけの独立のテーブルにする



- 第２正規形

社員

| 会社コード(主キー) | 社員ID(主キー) | 社員名 | 年齢 | 部署コード | 部署名 |
| ------------------ | -------------- | ------ | ---- | ---------- | ------ |
| C0001              | 000A           | 加藤   | 40   | D01        | 開発   |
| C0001              | 000B           | 藤本   | 32   | D02        | 人事   |
| C0001              | 001F           | 三島   | 50   | D03        | 営業   |
| C0002              | 000A           | 斉藤   | 47   | D03        | 営業   |
| C0002              | 009F           | 田島   | 25   | D01        | 開発   |
| C0002              | 010A           | 渋谷   | 33   | D04        | 総務   |

会社

| 会社コード(主キー) | 会社名 |
| ------------------ | ------ |
| C0001              | A商事  |
| C0002              | B化学  |

- これによって、「社員」テーブルも、「会社」テーブルも、すべての列が主キーに完全関数従属することになった

- 第２正規化というのは、「会社」と「社員」、**異なるレベルの実体(エンティティ)きちんとテーブルとして分離してやる**作業という見方もできる

> 正規化とは、現実世界の実体間にある階層の差を反映する手段でもある



## 第3正規形〜推移的関数従属

第２正規形

社員

| 会社コード(主キー) | 社員ID(主キー) | 社員名 | 年齢 | 部署コード | 部署名 |
| ------------------ | -------------- | ------ | ---- | ---------- | ------ |
| C0001              | 000A           | 加藤   | 40   | D01        | 開発   |
| C0001              | 000B           | 藤本   | 32   | D02        | 人事   |
| C0001              | 001F           | 三島   | 50   | D03        | 営業   |
| C0002              | 000A           | 斉藤   | 47   | D03        | 営業   |
| C0002              | 009F           | 田島   | 25   | D01        | 開発   |
| C0002              | 010A           | 渋谷   | 33   | D04        | 総務   |

会社

| 会社コード(主キー) | 会社名 |
| ------------------ | ------ |
| C0001              | A商事  |
| C0002              | B化学  |



### 推移的関数従属

- 「部署コード」と「部署名」のペアに注目する

- 会社コードがC0001のA商事について考えると、「社員」テーブルからは、開発、人事、営業という3つの部署が存在することがわかる

  - しかし、A商事の部署がこの3つだけであるという保証はない

  - 実は「広報」という部署ももっているかもしれない

  - こういう社員が一人もいない部署を、現在の第２正規形化した状態の「社員」テーブルには登録できない。

    → 社員IDが主キーの一部→そこをNullのままレコードを登録できない

  - このような不都合が発生する理由は、「社員」テーブルの中に、従属性が残っているから

    ｜部署コード｜→｜部署名｜

  - という関数従属が成立する

  - 一方、社員IDと部署コードの間にも

    ｜会社コード、社員ID｜→｜部署コード｜

  - という関数従属が存在する。つまり全体としては、

    ｜会社コード、社員ID｜→ ｜部署コード｜→｜部署名｜

  - という２段階の関数従属が存在する

  - このように、テーブル内部に存在する段階的な従属関係のことを、**推移的関数従属**と呼ぶ

### 第3正規化を行う

- 推移的関数従属によるデータ登録時の不都合を解消するには
  - テーブルを分割する

**第三正規形**

社員

| 会社コード(主キー) | 社員ID(主キー) | 社員名 | 年齢 | 部署コード |
| ------------------ | -------------- | ------ | ---- | ---------- |
| C0001              | 000A           | 加藤   | 40   | D01        |
| C0001              | 000B           | 藤本   | 32   | D02        |
| C0001              | 001F           | 三島   | 50   | D03        |
| C0002              | 000A           | 斉藤   | 47   | D03        |
| C0002              | 009F           | 田島   | 25   | D01        |
| C0002              | 010A           | 渋谷   | 33   | D04        |

会社

| 会社コード(主キー) | 会社名 |
| ------------------ | ------ |
| C0001              | A商事  |
| C0002              | B化学  |
| C0003              | C建設  |

部署

| 部署コード(主キー) | 部署名 |
| ------------------ | ------ |
| D01                | 開発   |
| D02                | 人事   |
| D03                | 営業   |
| D04                | 総務   |

