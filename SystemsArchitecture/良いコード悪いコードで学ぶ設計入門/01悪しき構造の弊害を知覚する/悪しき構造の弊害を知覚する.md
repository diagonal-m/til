# 悪しき構造の弊害を知覚する

- 設計をながしろにすると起こる弊害
  - コードを読み解くのに時間がかかる
  - バグを埋め込みやすくなる
  - 悪しき構造がさらに悪しき構造を誘発する

## 意味不明な命名

- 型名を表すInt、メモリ制御を表すMemoryやFlagなど、プログラミング用語やコンピュータ用語にもとづいた命名
  → 技術ベースでの命名を**技術駆動命名**と呼ぶ

- クラスやメソッドに対し番号付けで命名するのを**連番命名**と呼ぶ
- 技術駆動命名や連番命名は、意図がまったく読み取れない、悪しき手法である
  - 理解が難しくなる → 読みとくのに膨大な時間がかかる

> 意図や目的を表現した命名をすることで構造が簡明になる

### 理解を困難にする条件分岐のネスト

- if文の中にif文、さらにその中にif文...というように、if文が入れ子構造になっている入れ子構造を**ネスト**、または**ネストしている**と呼ぶ
  - ネストしているとコードの見通しが悪くなってくる
  - どこからどこまでがif文の処理ブロックなのか読みとくのが難しくなる
- 条件が複雑になると見通しが悪くなり、理解が困難になる
  - 理解困難になるとデバッグに時間がかかったり、仕様変更に時間がかかったりする
  - 分岐ロジックを正確に理解できずに仕様変更した場合、バグとなってしまう。

### さまざまな悪魔を招きやすいデータクラス

- データクラスは、設計が不十分なソフトウェアで頻繁に登場するクラス構造である
  - データクラスは単純な構造でありながら、さまざまな悪魔を招きやすく、開発者を苦しめる
  - 金額を扱うサービスを例に、データクラスの何がマズイのか見ていく
  - 業務契約を扱うサービスがあるとする
  - そのサービスでは契約金額を扱う仕様だとする
  - 何も考えずに実装すると以下のようなクラス構造になる

```java
// 契約金額
public class ContractAmount {
  public int amountInccludingTax;  // 税込金額
  public BigDecimal salesTaxRate;  // 消費税率
}
```

- 税込金額と消費税率をpublicなインスタンス変数として持ち、自由にデータの出し入れが可能な構造である。
- データを保持するだけのクラスを**データクラス**と呼ぶ
- データの入れ物だけでなく、税込金額を計算するロジックが当然必要になる
- あまり設計を考えないと、この手の計算ロジックはデータクラスとは別のクラスに実装されることが多い

```java
// 契約を管理するクラス
public class ContractManager {
  public ContractAmount contractAmount;
  
  // 税込金額を計算する
  public int calculateAmountIncludingTax(int amountExcludingTax, BigDecimal salesTaxRate) {
    // 省略
    return amountIncludingTax.intValue();
  }
  
  // 契約を締結する
  public void conclude() {
    // 省略
    contractAmount.salesTaxRate = salesTaxRate;
    // 省略
  }
}
```

- ごく小規模なアプリであれば、この構造は特に問題にならない
- 大規模になるにつれ、この構造はさまざまな悪魔を呼び寄せることになる



### 仕様変更時に牙をむく悪魔

- 関連するデータやロジックどうしが分散し、バラバラになっているのを**低凝集**という

### 重複コード

- 関連するコード同士が離れていると、関連するものどうしの把握が困難になる

- すでに実装済みの機能があるのに、別のメンバーが「この機能は未実装だ」と誤解し、同じようなロジックをいたるところに複数実装してしまう可能性がある。

  → 意図せず**重複コード**が量産されることになる

### 修正漏れ

- 重複コードが多く実装されている場合、仕様変更時にすべての重複コードを変更しなければならない
- 重複コードをすべて把握していないと、修正漏れが生じ、バグとなってしまう

### 可読性低下

- **可読性**とは、コードの意図や関係する処理の流れを、どれだけすばやく正確に読み取れるかを表す指標である
- 関連するコード同士が分散していると、重複コードも含め、関連するものすべてを探し出すのに膨大な時間が必要である

### 未初期化状態(生焼けオブジェクト)

```java
ContractAmount amount = new ContractAmount();
System.out.println(amount.salesTaxRate.toString());
```

- ↑のコードを実行すると、NullPointerExceptionが発生してしまう。
- 消費税率salesTaxRateはBigDecimal型として定義されているため、初期化しない限りnullである。
- ContractAmountが初期化の必要なクラスであることを利用側が知らないとバグが生じてしまう、不完全なクラスである。
- 初期化しないと使い者にならないクラス、または未初期化状態が発生しうるクラスを、**アンチパターン生焼けオブジェクト**と呼ぶ

### 不正値の混入

不正とは、仕様として正しくない状態を指す

- 注文数がマイナスになっている
- ゲームにおいて、ヒットポイントの値が最大を超えてしまっている

